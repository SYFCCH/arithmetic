# 二叉树的数据结构  
```java
public TreeNode{
    TreeNode left;
    TreeNode right;
    int val;
    
    public TreeNode() {}
            
    public TreeNode(int val) {this.val = val;}
    
    public TreeNode(int val,TreeNode left,TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }        
    }

```
# 1. 二叉树的前中后序遍历  
### 递归实现
###### 前序遍历    
```java
class Solution {
    List<Integer> list = new ArrayList<>();
    
    public List<Integer> preorderTraversal(TreeNode root) {
        preorder(root);
        return list;
    }

    public void preorder(TreeNode root) {
        //递归终止条件  
        if(root == null) {
            return;
        }
        list.add(root.val);
        preorder(root.left);
        preorder(root.right);
    }
}
```
中和后只是递归改一下位置而已   
![img.png](img.png)    

### 迭代实现,用栈模拟递归    

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。
此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了    
###### 前序遍历:先右进栈再左进栈
栈，然后先入右结点，再入左结点，这样出栈的顺序才是中左右
```java
class Solution {   
    //定义一个栈，实现前序遍历 
    Deque<TreeNode> stack = new ArrayDeque<>();
    List<Integer> list = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null) return list;
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode middle = stack.pop();
            list.add(middle.val);
            //先入右节点
            if(middle.right != null) {
                stack.push(middle.right);
            }
            if(middle.left != null) {
                stack.push(middle.left);
            }
        }
        return list;
    }
}
```

###### 中序遍历:灵活运用指针，帮助访问节点，栈用来处理节点
```java
class Solution {
    List<Integer> list =  new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null) return list;
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode curNode = root;

        while(curNode != null || !stack.isEmpty()) {
          if(curNode != null) {
              //先把中结点放进队列，然后一直遍历到最左的结点，遍历的结点都要放进栈里   
              stack.push(curNode);
              curNode = curNode.left;
          }else {   //遍历到最左的结点了
            curNode =  stack.pop();   //
            list.add(curNode.val);
            curNode = curNode.right;
          }
        }
        return list;
    }   
}
```
###### 后序遍历：先左入栈，再右入栈，最后反转结果，就是后序了
```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null) return list;
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()) {
             TreeNode cur = stack.pop();
             list.add(cur.val);
             if(cur.left != null) {
                 stack.push(cur.left);
             }
             if(cur.right != null) {
                 stack.push(cur.right);
             }
        }
        Collections.reverse(list);
        return list;
    }
}
```
# 2. 二叉树的层序遍历，用队列     
###### 第一种做法是用DFS
```java
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        check(root, 0);
        return resList;
    }

    public void check(TreeNode node, int deep) { //deep表示此刻node的深度
        if (node == null) {
            return;
        }
        deep++; //进一层深度加1
        if (resList.size() < deep) {
            List<Integer> list = new ArrayList<>();
            resList.add(list);
        }
        resList.get(deep - 1).add(node.val); //将node的值添加到对应深度的list
        check(node.left, deep);
        check(node.right, deep);
    }

```


###### 第二种做法是用BFS
```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    List<List<Integer>> FList   = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return FList;
        queue.offer(root);
        //队列不为空
        while(!queue.isEmpty()) {
            List<Integer> CList = new ArrayList<>();
            int len =  queue.size();
            //把原先队列中的所有左右节点入队
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                CList.add(cur.val);
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }

            }
            FList.add(CList);
        }
        return FList;
    }
}

```


# 3. 翻转二叉树    
第一种：递归之前序遍历  
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //确定递归结束条件
        if(root == null) return null;

        swapTree(root);
        invertTree(root.left);
        invertTree(root.right);
        return root;
    }
    
    public void swapTree(TreeNode root) {
        TreeNode temp  = root.left;
        root.left = root.right;
        root.right = temp;
    }  
}
```
递归之后序遍历
```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        //确定递归结束条件
        if(root == null) return null;

        invertTree(root.left);
        invertTree(root.right);
        swapTree(root);
        return root;
    }

    public void swapTree(TreeNode root) {
        TreeNode temp  = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```

递归之中序遍历就会导致重复交换了，不过也能做，就是本来遍历右节点的递归要改成左节点  

第二种是用BFS广度优先遍历来做   
```java
class Solution {
    Deque<TreeNode> queue = new ArrayDeque<>();
    public TreeNode invertTree(TreeNode root){
        if(root == null) return root;
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                //先右再左，右节点交换完后，就变成左节点了   
                if(cur.right != null) queue.offer(cur.right);
                if(cur.left != null) queue.offer(cur.left);
                swapTree(cur);
            }
        }
        return root;
    }
    public void swapTree(TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
```





# 4. 对称二叉树
第一种: 递归法
```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
            return digui(root.left,root.right);
    }
    // 比较内测和外侧的节点，然后如果有一个为空就不对称，都不存在直接返回true，如果都存在节点，则继续向下比较左子树和右子树的外侧节点和内测节点   
    public boolean digui(TreeNode left,TreeNode right) {
  
        if(left != null && right == null ) {
            return false;
        }
        if(left == null && right != null) {
            return  false;
        }
        //为null了当然就不能继续往下面递归了，直接返回结果了
        if(left == null && right == null ) {
            return true;
        }
        //只要相等就继续往深处递归
        if(left.val != right.val) {
            return false;
        }
        
        //往深处的节点继续递归判断
        boolean outside = digui(left.left,right.right);
        boolean inside = digui(left.right,right.left);
        //遍历到最下面后开始逐层返回，都为true自然就是true
        return outside && inside;
    }
}
```






# 5. 删除二叉搜索树中的节点  
![img_1.png](img_1.png)   
由于二叉树的特性，所以可以用二分查找快速定位
找到了节点也分几种情况： 
1. 无左子树，则直接右子树代替该节点
2. 无右子树，则直接左子树代替该节点
3. 左右都有，则将左子树放在右子树的最左的节点的左子树    
4. 啥都没有就不处理咯   

这里用递归法   

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        //首先确定递归结束条件 
        if(root == null) return null;
        if(root.val > key) {
            //在左子树找
        root.left = deleteNode(root.left,key);
        }else if(root.val < key){
            //在右子树找
        root.right = deleteNode(root.right,key);
        }else{
            //当前root节点就是要找的节点     
            //首先判断该节点左右子树的情况
            if(root.left == null){
                    return root.right;
            }else if(root.right == null) {
                  return root.left;
            }else if(root.left != null && root.right != null) {
                //把左子树的最左节点放在右子树的最左节点上
                TreeNode node = root.right;
                while(node.left != null) {
                    node = node.left;
                }
                //此时node就是最左节点了  
                node.left = root.left;
                root = root.right;
            }
        }
        return root;
    }
}
```


# 二叉树的最大深度

递归做法1:后序遍历,求高度
```java
class Solution {
    public int maxDepth(TreeNode root) {
            //判断递归结束条件  
            if(root == null) return 0;
            int left = maxDepth(root.left);
            int right = maxDepth(root.right);
            return Math.max(left,right)+1;
    }
}
```

迭代做法：层序遍历  
```java

class Solution {
    Deque<TreeNode> queue = new LinkedList<>();
    //迭代  
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 0;
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                //如果是null，不进队列，继续去找叶子节点  
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            depth++;
        }
        return depth;
    }
}

```



# 二叉树的最小深度
递归做法,这题用递归效率不好  
```java
class Solution {
    //后序遍历
    public int minDepth(TreeNode root) {
            //判断递归结束条件  
            if(root == null) return 0;  
            int left = minDepth(root.left);   //左
            int right = minDepth(root.right); //右
            //中
            if(root.left == null && root.right != null) {
                return right + 1;
            }
            if(root.right == null && root.left != null) {
                return left + 1;
            }
            return Math.min(left,right)+1;
    }
}
```
迭代做法： 层序遍历  
```java
class Solution {
    Deque<TreeNode> queue = new LinkedList<>();
    //迭代  
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int depth = 1;
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                //如果是叶子节点就直接返回，这就是最小的
                if(cur.left == null && cur.right == null) {
                    return depth;
                }
                //如果是null，不进队列，继续去找叶子节点  
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }
            }
            depth++;
        }
        return depth;
    }
}
```

# 完全二叉树

## 完全二叉树的节点个数  
1. 递归  
```java
class Solution {
    
    public int countNodes(TreeNode root) {
    if(root == null) return 0;
    int left = countNodes(root.left);
    int right = countNodes(root.right);
    return left + right + 1;
    }
}
```

2. 迭代
```java
class Solution {
    Deque<TreeNode> queue = new LinkedList<>();
    public int countNodes(TreeNode root) {
        if(root == null) return 0;
        int count = 0;
        queue.offer(root);
        while(!queue.isEmpty()) {
            int len = queue.size();
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                //如果是null，不进队列，继续去找叶子节点  
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }
                count++;
            }
        }
        return count;
    }
}
```

3. 利用完全二叉树的特性来写
```java
class Solution {
    public int countNodes(TreeNode root) {
        
    }
}
```

# 二叉树深度是从上到下，二叉树高度是从下往上算，所以根本上说求深度适合用前序遍历，求高度可以用后序遍历      

# 判断是否是平衡二叉树   
```java
class Solution {
    //求高度，从下往上，后序遍历  
    public boolean isBalanced(TreeNode root) {
            return getHeight(root) >= 0;
    }

    public int getHeight(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftHeight = getHeight(root.left);
        //每个子树都满足平衡二叉树  
        int rightHeight = getHeight(root.right);
        //返回当前节点的高度，初始为0，记得加1,高度指的是最下面叶子节点网上数的层数  
        if(leftHeight >= 0 && rightHeight >= 0 && Math.abs(leftHeight-rightHeight) <= 1) {
            return  Math.max(leftHeight,rightHeight) + 1;   
        }else {
            return -1;
        }
 
    }
}
```