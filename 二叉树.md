# 二叉树的数据结构  
```java
public TreeNode{
    TreeNode left;
    TreeNode right;
    int val;
    
    public TreeNode() {}
            
    public TreeNode(int val) {this.val = val;}
    
    public TreeNode(int val,TreeNode left,TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }        
    }

```
# 1. 二叉树的前中后序遍历  
### 递归实现
###### 前序遍历    
```java
class Solution {
    List<Integer> list = new ArrayList<>();
    
    public List<Integer> preorderTraversal(TreeNode root) {
        preorder(root);
        return list;
    }

    public void preorder(TreeNode root) {
        //递归终止条件  
        if(root == null) {
            return;
        }
        list.add(root.val);
        preorder(root.left);
        preorder(root.right);
    }
}
```
中和后只是递归改一下位置而已   
![img.png](img.png)    

### 迭代实现,用栈模拟递归    

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。
此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了    
###### 前序遍历:先右进栈再左进栈
栈，然后先入右结点，再入左结点，这样出栈的顺序才是中左右
```java
class Solution {   
    //定义一个栈，实现前序遍历 
    Deque<TreeNode> stack = new ArrayDeque<>();
    List<Integer> list = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        if(root == null) return list;
        stack.push(root);
        while(!stack.isEmpty()) {
            TreeNode middle = stack.pop();
            list.add(middle.val);
            //先入右节点
            if(middle.right != null) {
                stack.push(middle.right);
            }
            if(middle.left != null) {
                stack.push(middle.left);
            }
        }
        return list;
    }
}
```

###### 中序遍历:灵活运用指针，帮助访问节点，栈用来处理节点
```java
class Solution {
    List<Integer> list =  new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root == null) return list;
        Deque<TreeNode> stack = new ArrayDeque<>();
        TreeNode curNode = root;

        while(curNode != null || !stack.isEmpty()) {
          if(curNode != null) {
              //先把中结点放进队列，然后一直遍历到最左的结点，遍历的结点都要放进栈里   
              stack.push(curNode);
              curNode = curNode.left;
          }else {   //遍历到最左的结点了
            curNode =  stack.pop();   //
            list.add(curNode.val);
            curNode = curNode.right;
          }
        }
        return list;
    }   
}
```
###### 后序遍历：先左入栈，再右入栈，最后反转结果，就是后序了
```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        if(root == null) return list;
        Deque<TreeNode> stack = new ArrayDeque<>();
        stack.push(root);
        while(!stack.isEmpty()) {
             TreeNode cur = stack.pop();
             list.add(cur.val);
             if(cur.left != null) {
                 stack.push(cur.left);
             }
             if(cur.right != null) {
                 stack.push(cur.right);
             }
        }
        Collections.reverse(list);
        return list;
    }
}
```
# 2. 二叉树的层序遍历，用队列     
###### 第一种做法是用DFS
```java
class Solution {
    List<List<Integer>> resList = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        check(root, 0);
        return resList;
    }

    public void check(TreeNode node, int deep) { //deep表示此刻node的深度
        if (node == null) {
            return;
        }
        deep++; //进一层深度加1
        if (resList.size() < deep) {
            List<Integer> list = new ArrayList<>();
            resList.add(list);
        }
        resList.get(deep - 1).add(node.val); //将node的值添加到对应深度的list
        check(node.left, deep);
        check(node.right, deep);
    }

```


###### 第二种做法是用BFS
```java
class Solution {
    Queue<TreeNode> queue = new LinkedList<>();
    List<List<Integer>> FList   = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return FList;
        queue.offer(root);
        //队列不为空
        while(!queue.isEmpty()) {
            List<Integer> CList = new ArrayList<>();
            int len =  queue.size();
            //把原先队列中的所有左右节点入队
            while(len-- > 0) {
                TreeNode cur = queue.poll();
                CList.add(cur.val);
                if(cur.left != null) {
                    queue.offer(cur.left);
                }
                if(cur.right != null) {
                    queue.offer(cur.right);
                }

            }
            FList.add(CList);
        }
        return FList;
    }
}

```


# 3. 翻转二叉树    
